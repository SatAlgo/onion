#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <limits> // Required for numeric_limits<int>::max()

using namespace std;

// This function performs Non-Preemptive Priority Scheduling.
void priority_scheduling_simple() {
    // Input Data (Parallel Vectors)
    vector<int> pid = {1, 2, 3, 4};          // Process ID
    vector<int> arrival = {0, 1, 2, 4};      // Arrival Time (AT)
    vector<int> burst = {6, 8, 7, 3};        // Burst Time (BT)
    vector<int> priority = {2, 4, 1, 3};     // Priority (P): Smaller number = Higher Priority
    int n = pid.size();

    // Calculated Results and Status
    vector<int> completion(n);
    vector<int> turnaround(n);
    vector<int> waiting(n);
    vector<bool> is_completed(n, false);

    int current_time = 0;
    int processes_completed = 0;
    double total_wait = 0;
    double total_turnaround = 0;

    // Main Scheduling Loop: Runs until all processes are completed
    while (processes_completed < n) {
        int highest_priority = numeric_limits<int>::max(); // Lowest number found so far
        int best_index = -1;

        // 1. Selection Phase: Find the highest priority job that is READY
        for (int i = 0; i < n; ++i) {
            // Check if process has arrived AND is not completed
            if (arrival[i] <= current_time && !is_completed[i]) {
                // Check if this process has a SMALLER (higher) priority number
                if (priority[i] < highest_priority) {
                    highest_priority = priority[i];
                    best_index = i;
                }
                // Tie-breaker: If priorities are equal, use FCFS (earlier arrival)
                else if (priority[i] == highest_priority) {
                    // Check if the current candidate (best_index) or the new one (i) arrived first
                    if (best_index == -1 || arrival[i] < arrival[best_index]) {
                         best_index = i;
                    }
                }
            }
        }

        // 2. Idle Check: If no process is available, advance time
        if (best_index == -1) {
            current_time++;
            continue; 
        }

        // 3. Execution Phase: Execute the selected highest priority job fully
        int i = best_index;

        // Calculate timing metrics
        completion[i] = current_time + burst[i];
        turnaround[i] = completion[i] - arrival[i];
        waiting[i] = turnaround[i] - burst[i];

        // Update state for next iteration
        is_completed[i] = true;
        current_time = completion[i]; // CPU is now free at this time
        processes_completed++;

        // Accumulate totals
        total_wait += waiting[i];
        total_turnaround += turnaround[i];
    }

    // --- Display Results ---
    cout << "\n--- Priority Scheduling Results (Non-Preemptive) ---" << endl;
    cout << "(Note: Lower Priority Number = Higher Priority)" << endl;
    cout << left << setw(5) << "PID" << setw(10) << "Arrival" << setw(8) << "Burst"
         << setw(9) << "Priority" << setw(12) << "Completion" << setw(12) << "Turnaround" << setw(8) << "Wait" << endl;
    cout << "-------------------------------------------------------------------" << endl;

    for (int i = 0; i < n; ++i) {
        cout << left << setw(5) << pid[i] << setw(10) << arrival[i] << setw(8) << burst[i]
             << setw(9) << priority[i] << setw(12) << completion[i] << setw(12) << turnaround[i] << setw(8) << waiting[i] << endl;
    }

    // --- Calculate and Display Averages ---
    cout << fixed << setprecision(2);
    cout << "\nAverage Waiting Time: " << total_wait / n << endl;
    cout << "Average Turnaround Time: " << total_turnaround / n << endl;
}

int main() {
    priority_scheduling_simple();
    return 0;
}
