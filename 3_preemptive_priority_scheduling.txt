#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <limits> // Required for numeric_limits<int>::max()

using namespace std;

// This function performs Preemptive Priority Scheduling.
// Assumption: Lower priority number = Higher Priority (P1 is higher than P5)
void priority_scheduling_preemptive() {
    // Input Data (Parallel Vectors)
    vector<int> pid = {1, 2, 3, 4};          // Process ID
    vector<int> arrival = {0, 1, 2, 4};      // Arrival Time (AT)
    vector<int> burst = {6, 8, 7, 3};        // Burst Time (BT)
    vector<int> priority = {2, 4, 1, 3};     // Priority (P): Smaller number = Higher Priority
    int n = pid.size();

    // Working & Calculated Vectors
    vector<int> remaining(burst); // Tracks remaining execution time
    vector<int> completion(n, 0);
    vector<int> turnaround(n);
    vector<int> waiting(n);
    
    int current_time = 0;
    int processes_completed = 0;
    double total_wait = 0;
    double total_turnaround = 0;

    // Main Scheduling Loop: Runs until all processes are completed
    while (processes_completed < n) {
        int highest_priority = numeric_limits<int>::max(); // Used to find the lowest priority number
        int best_index = -1;

        // 1. Selection Phase: Find the highest priority job that is READY
        for (int i = 0; i < n; ++i) {
            // Check if process has arrived AND still has time remaining
            if (arrival[i] <= current_time && remaining[i] > 0) {
                
                // Check for preemption: If a higher priority job is found
                if (priority[i] < highest_priority) {
                    highest_priority = priority[i];
                    best_index = i;
                }
                // Tie-breaker: If priorities are equal, use FCFS (earlier arrival)
                else if (priority[i] == highest_priority) {
                    if (best_index == -1 || arrival[i] < arrival[best_index]) {
                         best_index = i;
                    }
                }
            }
        }

        // 2. Idle Check: If no process is available, advance time and continue
        if (best_index == -1) {
            current_time++;
            continue; 
        }

        // 3. Execution Phase: Execute the selected process for ONE time unit
        int i = best_index;
        
        // Execute for 1 unit
        remaining[i]--;
        current_time++; // Advance time by 1 unit

        // 4. Completion Check: If remaining time hits zero, the process is complete
        if (remaining[i] == 0) {
            completion[i] = current_time;
            turnaround[i] = completion[i] - arrival[i];
            
            // Waiting Time = Turnaround Time - Original Burst Time
            waiting[i] = turnaround[i] - burst[i]; 
            
            processes_completed++;

            total_wait += waiting[i];
            total_turnaround += turnaround[i];
        }
        // If remaining time > 0, the loop re-evaluates in the next iteration. 
        // If a higher priority job has now arrived (at current_time), preemption occurs.
    }

    // --- Display Results ---
    cout << "\n--- Preemptive Priority Scheduling Results ---" << endl;
    cout << "(Note: Lower Priority Number = Higher Priority)" << endl;
    cout << left << setw(5) << "PID" << setw(10) << "Arrival" << setw(8) << "Burst"
         << setw(9) << "Priority" << setw(12) << "Completion" << setw(12) << "Turnaround" << setw(8) << "Wait" << endl;
    cout << "-------------------------------------------------------------------" << endl;

    for (int i = 0; i < n; ++i) {
        cout << left << setw(5) << pid[i] << setw(10) << arrival[i] << setw(8) << burst[i]
             << setw(9) << priority[i] << setw(12) << completion[i] << setw(12) << turnaround[i] << setw(8) << waiting[i] << endl;
    }

    // --- Calculate and Display Averages ---
    cout << fixed << setprecision(2);
    cout << "\nAverage Waiting Time: " << total_wait / n << endl;
    cout << "Average Turnaround Time: " << total_turnaround / n << endl;
}

int main() {
    priority_scheduling_preemptive();
    return 0;
}
