#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>

using namespace std;

// This function performs the First-Come, First-Served (FCFS) scheduling.
void fcfs_scheduling_simple() {
    // Input Data: Processes are defined here.
    // NOTE: FCFS requires sorting by arrival time, so the data is initially defined
    // to match PID order, and then sorted based on arrival time below.
    vector<int> pid = {1, 2, 3, 4};      // Process ID
    vector<int> arrival = {0, 2, 4, 6};  // Arrival Time (AT)
    vector<int> burst = {7, 4, 1, 4};    // Burst Time (BT)
    int n = pid.size();

    // Data structure to hold all process information together for sorting
    // This uses a vector of tuples to combine data without a formal struct.
    vector<tuple<int, int, int>> processes; // {Arrival Time, Burst Time, Index}

    for (int i = 0; i < n; ++i) {
        // We push the AT first because we want to sort by it
        processes.emplace_back(arrival[i], burst[i], i);
    }

    // 1. FCFS Core Logic: Sort processes strictly by Arrival Time (AT).
    // If ATs are equal, the original order (index) is maintained.
    sort(processes.begin(), processes.end());

    // Calculated Results storage
    vector<int> completion(n);
    vector<int> turnaround(n);
    vector<int> waiting(n);
    
    int current_time = 0;
    double total_wait = 0;
    double total_turnaround = 0;

    // 2. Iterate through the sorted processes
    for (const auto& p : processes) {
        int arr_time = get<0>(p);
        int bus_time = get<1>(p);
        int original_index = get<2>(p);
        
        // --- Calculate Completion Time ---
        // If the CPU is idle (current_time < arrival_time), advance current_time
        if (current_time < arr_time) {
            current_time = arr_time;
        }
        
        // Completion Time (CT) = start time + burst time
        completion[original_index] = current_time + bus_time;
        current_time = completion[original_index]; // Update time for next job

        // --- Calculate Metrics ---
        // Turnaround Time (TAT) = CT - AT
        turnaround[original_index] = completion[original_index] - arr_time;

        // Waiting Time (WT) = TAT - BT
        waiting[original_index] = turnaround[original_index] - bus_time;
        
        // Accumulate totals (using double for accurate averaging later)
        total_wait += waiting[original_index];
        total_turnaround += turnaround[original_index];
    }

    // --- Display Results (Sort output back by PID for clear presentation) ---
    cout << "\n--- FCFS Scheduling Results (First-Come, First-Served) ---" << endl;
    cout << left << setw(5) << "PID" << setw(10) << "Arrival" << setw(8) << "Burst"
         << setw(12) << "Completion" << setw(12) << "Turnaround" << setw(8) << "Wait" << endl;
    cout << "---------------------------------------------------------" << endl;

    for (int i = 0; i < n; ++i) {
        cout << left << setw(5) << pid[i] << setw(10) << arrival[i] << setw(8) << burst[i]
             << setw(12) << completion[i] << setw(12) << turnaround[i] << setw(8) << waiting[i] << endl;
    }

    // --- Calculate and Display Averages ---
    cout << fixed << setprecision(2);
    cout << "\nAverage Waiting Time: " << total_wait / n << endl;
    cout << "Average Turnaround Time: " << total_turnaround / n << endl;
}

int main() {
    // Run the FCFS scheduling simulation
    fcfs_scheduling_simple();
    return 0;
}
